#!/gsc/software/linux-x86_64-centos5/python-3.4.3/bin/python3

'''
clusterTAS

Script for managing and submitting jobs to Genesis which first require transfer of files to Genesis.

Date: June 10, 2016
@author:    Scott Brown
            Canada's Michael Smith Genome Sciences Centre
            BC Cancer Research Centre
            Genome Science + Technology Graduate Program
            University of British Columbia
            Vancouver, BC, Canada
            http://www.holtlab.ca
            http://www.scottderekbrown.com
            sbrown@bcgsc.ca
            scottderekbrown@gmail.com
'''

## Import Libraries
import sys
import argparse
import getpass
import time
import os
import subprocess
import errno
import shutil
from collections import deque


## Hardcoded Vars

MAX_JOBS_HARD = 2000            ## Hardcoded max number of jobs to run on Genesis at once
USER = getpass.getuser()        ## Username
LOG_FILE = "clusterTAS_{}.log".format(time.strftime("%y%m%d-%H%M%S"))
TRANS_DEST_DIR = "transfer_scripts"
RES_DEST_DIR = "analysis_results"
MAX_OSCALL_TRIES = 10            ## Number of tries that a system call can fail before aborting

## Global Vars

transferFile = None             ## "Files to transfer" file
runFile = None                  ## "Scripts to run" file
GWD = None                      ## Genesis working directory
LWD = None                      ## Local working directory

GEN_MEM = None                  ## Genesis job memory requirements
QSUB_GEN = None                 ## String to use in Genesis qsub for mem
GEN_QSUB = None                 ## Genesis job qsub arguments
MAX_JOBS = None                 ## Maximum number of jobs to have running at once.
MAX_SPACE = None                ## Maximum amount of space to use on Genesis
DATE = None                     ## Add `date` command to beginning and end of Genesis script.
REFRESH = None                  ## Time to wait between checking if new job can be submitted
MOVERESULTS = None              ## Boolean for moving analysis results from Genesis filesystem
INFLATION = None                ## If limiting job submission by space, factor to multiply source files by for potential storage usage.
START_LINE = None               ## Line number of input file to start at
GWD_CLEAN = False               ## if GWD is created by the program, and moving results once done, delete GWD when done.
USE_APOLLO = False              ## boolean for using Apollo to transfer files
CLEANUP = None                  ## Whether transfered file should be deleted after processing
JOB_DIRS = True                 ## Whether subfolders should be made for each Genesis job
                                ## Note: this is set to True with no argument to change.
TEST = None                     ## Set test mode, only first job will be submitted. Once complete, will prompt user to continue or kill

DEBUG = None                    ## Set debug mode
VERB = None                     ## Set verbose mode

## Initialize Vars

doneRunning = False             ## boolean for when all jobs finished running on cluster
doneSubmitting = False          ## boolean for when all jobs submitted to apollo
fileSizes = {}                  ## dict of sizes of files * inflation factor. Key is job name
genesisSpace = 0                ## amount of space available on genesis at program start (bytes)
curGenesisSpace = 0             ## amount of space available on genesis at each iteration (bytes)
runningFileSize = 0             ## amount of space potentially used by files currently running (bytes)
apolloRunningJobs = set()       ## set of running apollo jobs (from qstat)
genesisRunningJobs = set()      ## set of running genesis jobs (from qstat)
toRun = {}                      ## dict of jobs yet to be submitted. {jobname:[[files,to,transfer],"genesisScript"]}
toRunKeys = deque()             ## list (queue) of job keys yet to be submitted. Maintains order of jobs.
running = set()                 ## set of currently running jobs
newCompleted = set()            ## set of newly completed jobs in each iteration
complete = set()                ## set of jobs that have completed on apollo and genesis
completeQ = set()               ## set of jobs that need to be processed before being "complete"
stats = ""                      ## string to hold running stats for each iteration
statsPrev = ""                  ## string to hold running stats for previous iteration
WAIT = False                    ## boolean to wait REFRESH time




''' Functions '''

def processArgs(args):
    ## check that all args given are in agreement and valid

    if DEBUG: print("\nSetting variables:")
    global transferFile
    transferFile = args.filesToTransfer
    if DEBUG: print("transferFile = {}".format(transferFile))
    global runFile
    runFile = args.scriptsToRun
    if DEBUG: print("runFile = {}".format(runFile))

    global LWD
    LWD = args.localWorkingDir
    ## make dir if it doesn't exist
    try:
        os.makedirs(LWD)
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
    if os.listdir(os.path.join(LWD)) != []:
        promptUserContinue("\nNOTE: {} is not empty. If clusterTAS has been run here before, file collisions or overwriting may occur for shared jobnames.".format(LWD))
    if DEBUG: print("LWD = {}".format(LWD))

    ## check for "/genesis" at start of genesisWorkingDir.
    global GWD
    global GWD_CLEAN
    if args.genesisWorkingDir.startswith("/genesis"):
        GWD = args.genesisWorkingDir[8:]
    elif not args.genesisWorkingDir.startswith("/"):
        logMessage("ERROR: Genesis working directory must be supplied as absolute path from root (starting with a '/').")
        sys.exit("Invalid Genesis working directory provided.")
    else:
        GWD = args.genesisWorkingDir
    try:
        os.makedirs(os.path.join("/genesis",GWD[1:]))
        GWD_CLEAN = True    ## because we made it
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
    if os.listdir(os.path.join("/genesis",GWD[1:])) != []:
        promptUserContinue("\nNOTE: {} is not empty. Performing analysis here may result in an error from file collisions.".format(os.path.join("/genesis",GWD[1:])))
    if DEBUG: print("GWD = {}".format(GWD))
    if DEBUG: print("GWD_CLEAN = {}".format(GWD_CLEAN))

    ## Create folder to hold transfer scripts
    try:
        os.makedirs(os.path.join(LWD, TRANS_DEST_DIR))
    except OSError as exception:
        if exception.errno != errno.EEXIST:
            raise
    if DEBUG: print("TRANS_DEST_DIR = {}".format(TRANS_DEST_DIR))

    global GEN_MEM
    global QSUB_MEM
    GEN_MEM = args.genMem
    if DEBUG: print("GEN_MEM = {}".format(GEN_MEM))
    if GEN_MEM:
        QSUB_MEM = "-l mem_free={}G -l mem_token={}G -l h_vmem={}G".format(GEN_MEM, GEN_MEM, GEN_MEM)
    if DEBUG: print("QSUB_MEM = {}".format(QSUB_MEM))
    global GEN_QSUB
    GEN_QSUB = args.genQsub
    if DEBUG: print("GEN_QSUB = {}".format(GEN_QSUB))

    ## check max jobs not > MAX_JOBS_HARD
    global MAX_JOBS
    if args.maxJobs and (args.maxJobs > MAX_JOBS_HARD):
        logMessage("\nNOTE: You requested {} jobs at once, but to limit cluster load, a maximum of {} jobs are allowed at once. --maxJobs set to {}.".format(args.maxJobs, MAX_JOBS_HARD, MAX_JOBS_HARD))
        MAX_JOBS = MAX_JOBS_HARD
    elif args.maxJobs:
        MAX_JOBS = args.maxJobs
    if DEBUG: print("MAX_JOBS = {}".format(MAX_JOBS))

    global MAX_SPACE
    if args.maxSpace and not args.spaceInflationFactor:
        logMessage("\nERROR: If --maxSpace is used, --spaceInflationFactor must be provided.")
        sys.exit("ERROR: If --maxSpace is used, --spaceInflationFactor must be provided.")
    MAX_SPACE = args.maxSpace
    if DEBUG: print("MAX_SPACE = {}".format(MAX_SPACE))

    global USE_APOLLO
    USE_APOLLO = args.USE_APOLLO
    if DEBUG: print("USE_APOLLO = {}".format(USE_APOLLO))

    global DATE
    DATE = args.DATE
    if DEBUG: print("DATE = {}".format(DATE))

    global REFRESH
    REFRESH = args.refresh
    if DEBUG: print("REFRESH = {}".format(REFRESH))

    ## if not deleting transfered file, and limiting by space, give warning.
    if args.MOVERESULTS and not args.CLEANUP:
        promptUserContinue("\nNOTE: Analysis results will be moved to {}, but you have not set deletion of transferred file (-c). Please be aware that this will result in the transfered file being moved to {} (unless it is removed by the analysis script you submitted).".format(os.path.join(LWD,RES_DEST_DIR),os.path.join(LWD,RES_DEST_DIR)))
    if args.MOVERESULTS and not JOB_DIRS:
        logMessage("\nERROR: If moving analysis results to {}, JOB_DIRS must be True.".format(os.path.join(LWD,RES_DEST_DIR)))
        sys.exit("ERROR: If moving analysis results to {}, JOB_DIRS must be True.".format(os.path.join(LWD,RES_DEST_DIR)))

    if args.MOVERESULTS:
        try:
            os.makedirs(os.path.join(LWD,RES_DEST_DIR))
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise
        if os.listdir(os.path.join(LWD,RES_DEST_DIR)) != []:
            promptUserContinue("\nNOTE: {} is not empty (created by clusterTAS to store completed results). Copying result directories here may result in an error.".format(os.path.join(LWD,RES_DEST_DIR)))
    if DEBUG: print("RES_DEST_DIR = {}".format(RES_DEST_DIR))

    ## check not limiting by space AND number of jobs
    if args.maxJobs and args.spaceInflationFactor:
        logMessage("\nERROR: Please only use one of (--maxJobs, [--maxSpace, --spaceInflationFactor]).")
        sys.exit("ERROR: Please only use one of (--maxJobs, [--maxSpace, --spaceInflationFactor]).")
    if args.spaceInflationFactor and args.spaceInflationFactor <= 1:
        logMessage("Space Inflation Factor must be greater than 1. You entered {}.".factor(args.spaceInflationFactor))
        sys.exit("Space Inflation Factor must be greater than 1. You entered {}.".factor(args.spaceInflationFactor))
    if args.spaceInflationFactor and not args.MOVERESULTS and not args.CLEANUP:
        promptUserContinue("\nNOTE: You are limiting job submission on available space (--spaceInflationFactor), but are not moving results off of Genesis (-L) and are not deleting transfered files (!-c). This scenario will likely result in running out of space.")
    global INFLATION
    INFLATION = args.spaceInflationFactor
    if DEBUG: print("INFLATION = {}".format(INFLATION))

    global MOVERESULTS
    MOVERESULTS = args.MOVERESULTS
    if DEBUG: print("MOVERESULTS = {}".format(MOVERESULTS))

    global START_LINE
    START_LINE = args.startAtLine
    if DEBUG: print("START_LINE = {}".format(START_LINE))

    global CLEANUP
    CLEANUP = args.CLEANUP
    if DEBUG: print("CLEANUP = {}".format(CLEANUP))

    global TEST
    TEST = args.TEST
    if DEBUG: print("TEST = {}".format(TEST))

    if DEBUG: print("USER = {}".format(USER))

def promptUserContinue(msg):
    logMessage(msg)
    response = ""
    while response not in ["y","n"]:
        logMessage("Are you sure you want to continue (y/n)? \n", False)
        response = input("Are you sure you want to continue (y/n)? ").lower()
    logMessage("{}\n".format(response), False)
    if response == "n":
        sys.exit("User ended.")

def getFreeGenesisSpace(genDir):
    if genDir.startswith("/"):
        genDir = genDir[1:]
    cmd = "df -B 1 {} | awk -F ' ' '{{print $3}}' | tail -1".format(os.path.join("/genesis", genDir))
    VALID_COM = False
    num_tries = 0
    while not VALID_COM:
        call = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (res, err) = call.communicate()
        if err.decode('ascii') == "":
            VALID_COM = True
        elif num_tries == MAX_OSCALL_TRIES:
            logMessage("Unable to complete system call. Aborting...")
            abortClusterTAS()
            sys.exit("Unable to get free Genesis space.")
        else:
            num_tries += 1
            logMessage("ERROR IN GETTING FREE GENESIS SPACE: {}\nError: {}".format(cmd, str(err.decode('ascii'))))
            logMessage("Waiting 1 minute to try again...")
            time.sleep(60)

    return int(res.decode('ascii'))

def spaceNeededForFile(file, inflation_factor):
    cmd = "ls -lL {} | awk -F ' ' '{{print $5}}'".format(file)
    VALID_COM = False
    num_tries = 0
    while not VALID_COM:
        call = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (res, err) = call.communicate()
        if err.decode('ascii') == "":
            VALID_COM = True
        elif num_tries == MAX_OSCALL_TRIES:
            logMessage("Unable to complete system call. Aborting...")
            abortClusterTAS()
            sys.exit("Unable to get space needed for file to transfer.")
        else:
            num_tries += 1
            logMessage("ERROR IN GETTING FILE SIZE: {}\nError: {}".format(cmd, str(err.decode('ascii'))))
            logMessage("Waiting 1 minute to try again...")
            time.sleep(60)

    return int(res.decode('ascii')) * inflation_factor

def getJobDirSize(jobDir):
    cmd = "du -b {} | awk -F ' ' '{{print $1}}'".format(jobDir)
    VALID_COM = False
    num_tries = 0
    while not VALID_COM:
        call = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (res, err) = call.communicate()
        if err.decode('ascii') == "":
            VALID_COM = True
        elif num_tries == MAX_OSCALL_TRIES:
            logMessage("Unable to complete system call. Aborting...")
            abortClusterTAS()
            sys.exit("Unable to get job directory size.")
        else:
            num_tries += 1
            logMessage("ERROR IN GETTING JOB DIR SIZE: {}\nError: {}".format(cmd, str(err.decode('ascii'))))
            logMessage("Waiting 1 minute to try again...")
            time.sleep(60)

    return int(res.decode('ascii'))

def isInteger(s):
    try:
        int(s)
        return True
    except ValueError:
        return False

def readFile(filename):
    filedat = []
    try:
        for line in open(filename, "r"):
            line = line.rstrip()
            if len(line) > 0:
                filedat.append(line)
    except IOError:
        logMessage("Error opening file: {}".format(filename))
        sys.exit("Error opening file: {}".format(filename))

    return filedat

def getRunningJobs(cluster):
    '''returns set of scripts currently running or in queue'''
    if cluster == "apollo":
        cmd = "ssh {}@apollo.bcgsc.ca 'qstat -u {} -r | grep jobname;'".format(USER, USER)
    elif cluster == "genesis":
        cmd = "ssh {}@genesis.bcgsc.ca 'source /etc/profile.d/sge.sh; qstat -u {} -r | grep jobname;'".format(USER, USER)
    VALID_COM = False
    num_tries = 0
    while not VALID_COM:
        call = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        (res, err) = call.communicate()
        if err.decode('ascii') == "":
            VALID_COM = True
        elif num_tries == MAX_OSCALL_TRIES:
            logMessage("Unable to complete system call. Aborting...")
            abortClusterTAS()
            sys.exit("Unable to get running jobs on {}".format(cluster))
        else:
            num_tries += 1
            logMessage("ERROR IN RUNNING SSH COMMAND: {}\nError: {}".format(cmd, str(err.decode('ascii'))))
            logMessage("Waiting 1 minute to try again...")
            time.sleep(60)

    jobs = res.decode('ascii')  # "  Full jobname:  jobname_250.sh\n Full jobname: jobname_251.sh\n"
    # the following is a little clunky, but should work.
    jobs = jobs.replace(" ", "")  # "Fulljobname:jobname_250.sh\nFulljobname:jobname_251.sh\n"
    jobs = jobs.rstrip()  # "Fulljobname:jobname_250.sh\nFulljobname:jobname_251.sh"
    jobs = jobs.replace("\n", ":")  # "Fulljobname:jobname_250.sh:Fulljobname:jobname_251.sh"
    jobs = jobs.replace(".", ":")  # "Fulljobname:jobname_250:sh:Fulljobname:jobname_251:sh"
    jobs = jobs.split(":")  # ["Fulljobname","jobname_250","sh","Fulljobname","jobname_251","sh"]
    ## starting at index 1, take every 3rd:
    jobs = jobs[1::3]  # ["jobname_250","jobname_251"]

    return set(jobs)

def logMessage(msg, yesPrint = True):
    log = open(os.path.join(LWD,LOG_FILE), "a")
    log.write("{}\n".format(msg))
    log.close()
    if yesPrint: print(msg.rstrip())

def abortClusterTAS():
    running_file = open(os.path.join(LWD,"{}.abortRunning".format(LOG_FILE)), "w")
    running_file.write("\n".join(running))
    running_file.close()

    computeDone_file = open(os.path.join(LWD,"{}.abortComputeDone".format(LOG_FILE)), "w")
    computeDone_file.write("\n".join(newCompleted | completeQ))
    computeDone_file.close()

    complete_file = open(os.path.join(LWD,"{}.abortComplete".format(LOG_FILE)), "w")
    complete_file.write("\n".join(complete))
    complete_file.close()

    logMessage("Resume at line {}.".format(len(transfer) - len(toRun) + 1))

def pauseState():
    resp = ""
    while resp not in ["c","q"]:
        logMessage("\n==cluserTAS is PAUSED==\n")
        logMessage("You can [c]ontinue, [q]uit, or [m]odify variables.")
        resp = input().lower()
        while resp not in ["c","q","m"]:
            resp = input("You can [c]ontinue, [q]uit, or [m]odify variables.\n").lower()
        if resp == "m":
            global MAX_JOBS
            global REFRESH
            global DEBUG
            global VERB
            logMessage("Options\t(current):\n[1]\tModify MAX_JOBS ({})\n[2]\tModify REFRESH ({})\n[3]\tToggle DEBUG ({})\n[4]\tToggle VERB ({})\n[b]\tBack\n".format(MAX_JOBS, REFRESH, DEBUG, VERB))
            mod = input()
            while mod not in ["1","2","3","4","b"]:
                mod = input("Options\t(current):\n[1]\tModify MAX_JOBS ({})\n[2]\tModify REFRESH ({})\n[3]\tToggle DEBUG ({})\n[4]\tToggle VERB ({})\n[b]\tBack\n".format(MAX_JOBS, REFRESH, DEBUG, VERB)).lower()
            if mod == "1":
                ## update maxJobs
                logMessage("Enter maximum jobs to be run concurrently.\n")
                mj = input()
                VALID = False
                while not VALID:
                    if mj.isnumeric() and int(mj) > MAX_JOBS_HARD:
                        logMessage("Number entered is too high. Max allowed is {}.".format(MAX_JOBS_HARD))
                        mj = input("Enter maximum jobs to be run concurrently.\n")
                    elif not mj.isnumeric():
                        mj = input("Please enter an integer number.\n")
                    else:
                        VALID = True
                MAX_JOBS = int(mj)
                logMessage("MAX_JOBS set to {}".format(MAX_JOBS))
            elif mod == "2":
                ## update REFRESH
                logMessage("Enter frequency for REFRESH (seconds)\n")
                rs = input()
                while not rs.isnumeric():
                    rs = input("Please enter an integer number (seconds)\n")
                REFRESH = int(rs)
                logMessage("REFRESH set to {}".format(REFRESH))
            elif mod == "3":
                ## update DEBUG
                DEBUG = not DEBUG
                logMessage("DEBUG set to {}".format(DEBUG))
            elif mod == "4":
                ## update VERB
                VERB = not VERB
                logMessage("VERB set to {}".format(VERB))

    return resp

if __name__ == "__main__":

    ## Deal with command line arguments
    parser = argparse.ArgumentParser(description = "Script for managing and submitting jobs to \
        Genesis which first require transfer of files to Genesis.")

    parser.add_argument("filesToTransfer",
                        help = "File of files to transfer. No header. Tab separated files if \
                        more than one, one job per line.", type = str)
    parser.add_argument("scriptsToRun",
                        help = "File of script to submit on Genesis, one job per line \
                        (matching lines in 'filesToTransfer'). \
                        No header. Format: Unique_jobname [tab] script_to_execute;", type = str)
    parser.add_argument("genesisWorkingDir",
                        help = "Target directory on genesis. Absolute path from root.", type = str)
    parser.add_argument("localWorkingDir",
                        help = "Local working directory (absolute path from root) where transfer \
                        scripts and analysis results (unless opting to not move results) are \
                        stored", type = str)

    parser.add_argument("--genMem", metavar = "N",
                        help = "Memory required (in GB) for Genesis job submission - builds \
                        qsub args.", type = int, default = None)
    parser.add_argument("--genQsub", metavar = '"qsub args"',
                        help="Additional arguments to be passed to the qsub command \
                        (see man qsub for more details).", type = str, default = "")
    parser.add_argument("--maxJobs", metavar = "N",
                        help = "Maximum number of jobs to run concurrently.",
                        type = int, default = None)
    parser.add_argument("--maxSpace", metavar = "N",
                        help = "Maximum amount of space to be used on Genesis (in bytes). Default \
                        is total space available on your Genesis working directory.", type = int,
                        default = None)
    parser.add_argument("--noApollo", action = "store_false", dest = "USE_APOLLO",
                        help = "Flag for preventing Apollo from being used to transfer files. \
                        If set, the server used to run clusterTAS will copy files to Genesis. \
                        This is useful for small files.")
    parser.add_argument("--noDate", action = "store_false", dest = "DATE",
                        help = "Flag for preventing the 'date' command being added to \
                        Genesis script.")
    parser.add_argument("--refresh", metavar = "N",
                        help = "Time (in seconds) to wait between checking if next job can be \
                        submitted (default = 120).", type = int, default = 120)
    parser.add_argument("--spaceInflationFactor", "--spaceInflation", metavar = "N",
                        help = "Limits number of jobs submitted by available space. Expected \
                        maximum space used by a job is set to [size of files to be transfered] X \
                        [spaceInflationFactor]. If a job uses more space than this, may run out of \
                        disk space on Genesis.", type = int, default = None)
    parser.add_argument("--startAtLine", metavar = "N",
                        help = "Line of input files to start at (default = 1).",
                        type = int, default = 1)

    parser.add_argument("-c", "--cleanup", action = "store_true", dest = "CLEANUP",
                        help = "Flag for deleting transfered file after Genesis processing complete.")
    parser.add_argument("-L", "--leaveResults", action = "store_false", dest = "MOVERESULTS",
                        help = "Flag for leaving results on Genesis filesystem.")
    parser.add_argument("-t", "--test", action = "store_true", dest = "TEST",
                        help = "Flag for setting test mode. Only first job will be submitted. \
                        Will prompt user to continue, or exit.")

    parser.add_argument("-d", "--debug", action = "store_true", dest = "DEBUG",
                        help = "Flag for setting debug output.")
    parser.add_argument("-v", "--verbose", action = "store_true", dest = "VERB",
                        help = "Flag for setting verbose output.")
    args = parser.parse_args()

    ## Set Global Vars
    DEBUG = args.DEBUG
    VERB = args.VERB

    ## process command line arguments and initialize
    processArgs(args)

    ## Initialize log file
    log = open(os.path.join(LWD,LOG_FILE), "w")
    log.write("clusterTAS Genesis Analysis Management Script\n")
    log.write("Python version: {}\n".format(sys.version))
    log.write("Server: {}\n".format(os.uname()[1]))
    log.write("Current directory: {}\n".format(os.getcwd()))
    log.write("Command: {}\n".format(" ".join(sys.argv)))
    log.write("Time: {}\n".format(time.strftime("%Y/%m/%d %T")))
    log.write("-----------------------\n")
    log.write("Variables set:\n")
    log.write("MAX_JOBS_HARD:\t\t{}\n".format(MAX_JOBS_HARD))
    log.write("USER:\t\t\t{}\n".format(USER))
    log.write("LOG_FILE:\t\t{}\n".format(LOG_FILE))
    log.write("TRANS_DEST_DIR:\t\t{}\n".format(TRANS_DEST_DIR))
    log.write("RES_DEST_DIR:\t\t{}\n".format(RES_DEST_DIR))
    log.write("MAX_OSCALL_TRIES:\t{}\n".format(MAX_OSCALL_TRIES))
    log.write("transferFile:\t\t{}\n".format(transferFile))
    log.write("runFile:\t\t{}\n".format(runFile))
    log.write("GWD:\t\t\t{}\n".format(GWD))
    log.write("LWD:\t\t\t{}\n".format(LWD))
    log.write("GEN_MEM:\t\t{}\n".format(GEN_MEM))
    log.write("QSUB_GEN:\t\t{}\n".format(QSUB_GEN))
    log.write("GEN_QSUB:\t\t{}\n".format(GEN_QSUB))
    log.write("MAX_JOBS:\t\t{}\n".format(MAX_JOBS))
    log.write("MAX_SPACE:\t\t{}\n".format(MAX_SPACE))
    log.write("DATE:\t\t\t{}\n".format(DATE))
    log.write("REFRESH:\t\t{}\n".format(REFRESH))
    log.write("MOVERESULTS:\t\t{}\n".format(MOVERESULTS))
    log.write("INFLATION:\t\t{}\n".format(INFLATION))
    log.write("START_LINE:\t\t{}\n".format(START_LINE))
    log.write("GWD_CLEAN:\t\t{}\n".format(GWD_CLEAN))
    log.write("USE_APOLLO:\t\t{}\n".format(USE_APOLLO))
    log.write("CLEANUP:\t\t{}\n".format(CLEANUP))
    log.write("JOB_DIRS:\t\t{}\n".format(JOB_DIRS))
    log.write("TEST:\t\t\t{}\n".format(TEST))
    log.write("DEBUG:\t\t\t{}\n".format(DEBUG))
    log.write("VERB:\t\t\t{}\n".format(VERB))
    log.write("-----------------------\n\n")
    log.close()



    ## READ IN FILES TO TRANSFER
    transfer = readFile(transferFile)

    ## READ IN SCRIPTS TO RUN
    scripts = readFile(runFile)

    ## check that # files and # scripts match
    if len(transfer) != len(scripts):
        logMessage("ERROR: Number of entries in Files to Transfer and Scripts to Run does not match.")
        sys.exit("ERROR: Number of entries in Files to Transfer and Scripts to Run does not match.")

    ## Set up toRun dict.
    for i in range(0, len(transfer)):
        if i + 1 >= START_LINE:
            transferLine = transfer[i].rstrip().split("\t")
            scriptsLine = scripts[i].rstrip().split("\t")

            if scriptsLine[0] in toRun:
                logMessage("ERROR: Non-unique jobname given to line {} of Scripts to Run: {}\nPlease make sure all jobs have a unique name.".format(i + 1, scriptsLine[0]))
                sys.exit("ERROR: Non-unique jobname given to line {} of Scripts to Run: {}\nPlease make sure all jobs have a unique name.".format(i + 1, scriptsLine[0]))

            if " " in scriptsLine[0] or "." in scriptsLine[0] or ":" in scriptsLine[0]:
                logMessage("ERROR: Jobname cannot contain spaces ( ), periods (.), or colons (:) - {}".format(scriptsLine[0]))
                sys.exit("ERROR: Jobname cannot contain spaces ( ), periods (.), or colons (:) - {}".format(scriptsLine[0]))

            if isInteger(scriptsLine[0][0:1]):
                logMessage("ERROR: Jobname cannot start with a number - {}".format(scriptsLine[0]))
                sys.exit("ERROR: Jobname cannot start with a number - {}".format(scriptsLine[0]))

            toRun[scriptsLine[0]] = [transferLine, scriptsLine[1]]
            toRunKeys.append(scriptsLine[0])

    if DEBUG: print("toRun looks like: \n{}".format(toRun))

    ## get max available Genesis space before submitting anything.
    if INFLATION:
        genesisSpace = getFreeGenesisSpace(GWD)
        curGenesisSpace = genesisSpace
        if DEBUG: print("genesisSpace = {}".format(genesisSpace))

    if MAX_SPACE and MAX_SPACE > genesisSpace:
        logMessage("NOTE: Requested max space to use on Genesis ({} bytes) is more than is currently available ({} bytes). Max space set to total available space ({} bytes)".format(MAX_SPACE, genesisSpace, genesisSpace))
    elif INFLATION and not MAX_SPACE:
        ## Limit by space, but max space not given
        MAX_SPACE = genesisSpace
    else:
        genesisSpace = MAX_SPACE
        curGenesisSpace = genesisSpace

    ## Get first job to process

    jobname = None
    files = None
    genScript = None





    #####################
    ## MAIN LOGIC LOOP ##
    #####################

    try:

        firstjob = True
        while not doneRunning:
            try:    ## Catches KeyboardInterrupt and pauses loop.
                ######################
                ## Get stat updates ##
                ######################

                ## Update what is running and what has completed
                if USE_APOLLO:
                    apolloRunningJobs = getRunningJobs("apollo")
                else:
                    apolloRunningJobs = set()
                genesisRunningJobs = getRunningJobs("genesis")

                if DEBUG: print("apolloRunningJobs = {}".format(apolloRunningJobs))
                if DEBUG: print("genesisRunningJobs = {}".format(genesisRunningJobs))

                ## get newly completed jobs
                if DEBUG: print("running = {}".format(running))
                newCompleted = running - (apolloRunningJobs | genesisRunningJobs)
                if DEBUG: print("newCompleted = {}".format(newCompleted))
                running -= newCompleted
                if DEBUG: print("Updated running = {}".format(running))

                for job in newCompleted:
                    logMessage("Computation completed:\t{}".format(job))

                ## add completed jobs to the completed queue
                completeQ |= newCompleted

                if not firstjob:
                    if VERB:
                        if USE_APOLLO:
                            logMessage("There are currently {} submitted jobs on Apollo and {} submitted jobs on Genesis.".format(len(apolloRunningJobs), len(genesisRunningJobs)))
                        else:
                            logMessage("There are currently {} submitted jobs on Genesis.".format(len(genesisRunningJobs)))
                    if VERB: logMessage("{} jobs have computation done but need to be cleaned up.".format(len(completeQ)))
                    if VERB: logMessage("{} jobs have completed.".format(len(complete)))
                    if VERB: logMessage("There are {} jobs remaining to be submitted.".format(len(toRun)))
                if not VERB:
                    logMessage("{} jobs submitted, {} jobs complete, {} jobs remaining.".format(len(apolloRunningJobs)+len(genesisRunningJobs), len(complete), len(toRun)))

                ## if there are jobs that are done but need to be cleaned up
                if len(completeQ) > 0:
                    jn = completeQ.pop()    ## shortens completeQ

                    if INFLATION:
                        ## free space
                        curGenesisSpace += fileSizes[jn]
                        if not MOVERESULTS:
                            ## if not moving results off of Genesis, need to see how much space results take
                            curGenesisSpace -= getJobDirSize(os.path.join("/genesis",GWD[1:],jn))
                    if MOVERESULTS:
                        ## move it
                        logMessage("Moving {} to {}.".format(os.path.join("/genesis/", GWD[1:], jn), os.path.join(LWD,RES_DEST_DIR)))
                        try:
                            if(os.path.exists(os.path.join(LWD,RES_DEST_DIR, jn))):
                                logMessage("Results directory {} exists. Overwriting.".format(os.path.join(LWD,RES_DEST_DIR, jn))))
                                os.remove(os.path.join(LWD,RES_DEST_DIR, jn)))
                            shutil.move(os.path.join("/genesis/", GWD[1:], jn), os.path.join(LWD,RES_DEST_DIR))
                        except OSError as exception:
                            logMessage("ERROR: {}".format(exception))
                            abortClusterTAS()
                            sys.exit("Error moving complete job directory back to projects space.")

                    complete.add(jn)    ## puts job into complete set.
                    logMessage("Completed:\t{}".format(jn))

                    ## Check if need to loop back to process more jobs in completeQ
                    if len(completeQ) > 0:
                        WAIT = False


                ###################
                ## Check if done ##
                ###################

                ## Check if done running
                if len(apolloRunningJobs) == 0 and len(genesisRunningJobs) == 0 and doneSubmitting and len(completeQ) == 0:
                    doneRunning = True
                    break

                ## Check if waiting for jobs to finish
                elif doneSubmitting and len(completeQ) == 0:
                    logMessage("All jobs submitted, {} jobs still running. Waiting {} seconds to check for completion.".format(len(running),REFRESH))
                    WAIT = True

                ###################
                ## Get next job  ##
                ## if not loaded ##
                ###################

                elif not jobname and not doneSubmitting:
                    #jobToProcess = toRun.popitem()
                    keyToProcess = toRunKeys.popleft()
                    jobToProcess = toRun[keyToProcess]
                    del toRun[keyToProcess]

                    if DEBUG: print("jobToProcess = {}".format(jobToProcess))

                    jobname = keyToProcess
                    files = jobToProcess[0]
                    genScript = jobToProcess[1]

                    if not genScript.endswith(";"):
                        genScript += ";"

                    logMessage("Queued for preparation:\t{}.".format(jobname))

                    if DEBUG: print("jobname = {}".format(jobname))
                    if DEBUG: print("files = {}".format(files))
                    if DEBUG: print("genScript = {}".format(genScript))

                    ## Get file sizes for this job
                    if INFLATION:
                        fileSizes[jobname] = 0
                        for f in files:
                            fileSizes[jobname] += spaceNeededForFile(f, INFLATION)
                        if VERB: logMessage("Job {} requires {} bytes.".format(jobname,fileSizes[jobname]))


                ######################
                ## CHECK IF ALLOWED ##
                ## PROCESS NEXT JOB ##
                ######################

                ## Three cases:
                ## 1 - not limiting by number of jobs or space
                ## 2 - limiting by number of jobs, and a job can be added
                ## 3 - limiting by space, and there is space left.
                if not doneSubmitting and ((not MAX_JOBS and not INFLATION) or (MAX_JOBS and len(apolloRunningJobs) + len(genesisRunningJobs) < MAX_JOBS) or (INFLATION and curGenesisSpace - fileSizes[jobname] > 0)):

                    WAIT = False

                    logMessage("Preparing:\t{}.".format(jobname))

                    ## prepare jobs
                    ## make transfer script
                    ascript = ""
                    jobDest = ""

                    if JOB_DIRS:  ## if want separate dir for each job
                        jobDest = os.path.join("/genesis/", GWD[1:], jobname)
                        ## note GWD[1:] to remove the leading /
                        if DEBUG: print("jobDest = {}".format(jobDest))
                    else:
                        jobDest = os.path.join("/genesis/", GWD[1:])

                    ascriptHeader = "#! /bin/sh\n\n#$ -S /bin/sh\n\n"

                    for f in files:
                        ascript += "/bin/cp -p {} {}; ".format(f, jobDest)

                    ascript += "ssh {}@genesis.bcgsc.ca 'cd {}; source /etc/profile.d/sge.sh; qsub {} {} {}.sh;';\n".format(USER, jobDest.replace("/genesis", ""), QSUB_MEM, GEN_QSUB, jobname)

                    if DEBUG:
                        if USE_APOLLO:
                            print("Transfer script to be submitted on Apollo: \"{}\"".format(ascript))
                        else:
                            print("Transfer script to be submitted on {}".format(os.uname()[1]))

                    ## write transfer script
                    transferScript = open(os.path.join(LWD, TRANS_DEST_DIR, "{}.sh".format(jobname)), "w")
                    transferScript.write("{}{}".format(ascriptHeader, ascript))
                    transferScript.close()

                    os.chmod(os.path.join(LWD, TRANS_DEST_DIR, "{}.sh".format(jobname)),0o755)

                    ## make genesis script
                    gscript = ""
                    genDir = jobDest.replace("/genesis", "")

                    gscriptHeader = "#! /bin/sh\n\n#Automatically generated by clusterTAS\n\n#$ -S /bin/sh\n\n"

                    if DATE:
                        gscript += "date; "
                    gscript += "cd {}; ".format(genDir)
                    gscript += genScript
                    if CLEANUP:
                        for f in files:
                            f2remove = os.path.basename(f)
                            gscript += " /bin/rm {};".format(f2remove)
                    if DATE:
                        gscript += " date;"

                    ## write genesis script
                    if JOB_DIRS:
                        try:
                            os.makedirs(os.path.join("/genesis", GWD[1:], jobname))
                        except OSError as exception:
                            if exception.errno != errno.EEXIST:
                                raise

                    if DEBUG: print("Analysis script to be submitted on Genesis: \"{}\"".format(gscript))

                    genesisScript = open(os.path.join(jobDest, "{}.sh".format(jobname)), "w")
                    genesisScript.write("{}{}".format(gscriptHeader, gscript))
                    genesisScript.close()

                    os.chmod(os.path.join(jobDest, "{}.sh".format(jobname)),0o755)

                    ## submit transfer job
                    logMessage("Submitting:\t{}.".format(jobname))
                    if USE_APOLLO:
                        subCmd = "ssh {}@apollo.bcgsc.ca 'cd {}; qsub -q thosts.q -P transfer {}.sh;'".format(USER, os.path.join(LWD, TRANS_DEST_DIR), jobname)
                    else:
                        subCmd = "cd {}; sh {}.sh;".format(os.path.join(LWD, TRANS_DEST_DIR), jobname)
                    VALID_COM = False
                    num_tries = 0
                    while not VALID_COM:
                        call = subprocess.Popen(subCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
                        (res, err) = call.communicate()
                        if err.decode('ascii') == "":
                            VALID_COM = True
                        elif num_tries == MAX_OSCALL_TRIES:
                            logMessage("Unable to complete system call. Aborting...")
                            abortClusterTAS()
                            sys.exit("Error submitting transfer script.")
                        else:
                            num_tries += 1
                            logMessage("ERROR SUBMITTING TRANSFER SCRIPT!\nError: {}".format(str(err.decode('ascii'))))
                            logMessage("Waiting 1 minute to try again...")
                            time.sleep(60)

                    ## if need to track, add submitted job to list.

                    running.add(jobname)
                    if INFLATION:
                        curGenesisSpace -= fileSizes[jobname]

                    ## If in test mode and first job has been submitted.
                    if TEST and firstjob:
                        ## check with user to continue or not
                        response = ""
                        logMessage("TEST STATE: The job '{}' has been submitted. Check the result.".format(jobname))
                        while response not in ["c", "e"]:
                            logMessage("Do you want to [c]ontinue with remaining jobs, or [e]xit? \n", noPrint = True)
                            response = input("Do you want to [c]ontinue with remaining jobs, or [e]xit? ").lower()
                        logMessage("{}\n".format(response))
                        if response == "c":
                            TEST = False
                            jobname = None
                            files = None
                            genScript = None

                        elif response == "e":
                            logMessage("Exiting")
                            sys.exit("Exiting TEST state.")

                    ## if toRun is empty, done submitting.
                    if len(toRun) == 0:
                        doneSubmitting = True
                        logMessage("All jobs submitted, {} jobs still running. Waiting {} seconds to check for completion.".format(len(running),REFRESH))
                        WAIT = True

                    ## reset vars since we submitted this job.
                    firstjob = False
                    jobname = None
                    files = None
                    genScript = None

                ## Go into WAIT unless there are jobs to move back
                elif MAX_JOBS and len(completeQ) == 0:
                    ## failed to submit next job because too many jobs
                    if not doneSubmitting:
                        logMessage("Too many jobs in queue, will recheck every {} seconds.".format(REFRESH))
                    WAIT = True

                elif INFLATION and len(completeQ) == 0:
                    ## failed to submit next job because too little space
                    if not doneSubmitting:
                        if VERB: logMessage("INITIAL free space on genesis: {} bytes.".format(genesisSpace))
                        if VERB: logMessage("CURRENT free space on genesis: {} bytes.".format(curGenesisSpace))
                        logMessage("Not enough free space for job {} (requires {} bytes, only {} are available).\nWill recheck every {} seconds".format(jobname, fileSizes[jobname], curGenesisSpace, REFRESH))
                    WAIT = True

                if WAIT:
                    print("Waiting {} seconds...".format(REFRESH))
                    time.sleep(REFRESH)
                else:
                    print("Holding 1 second for safe time to pause...")
                    time.sleep(1)

            except KeyboardInterrupt:
                res = pauseState()
                if res == "c":
                    ## continue
                    pass
                elif res == "q":
                    abortClusterTAS()
                    sys.exit("User-interrupted from PAUSE state.")

    except:
        logMessage("An EXCEPTION was encountered. Aborting...")
        abortClusterTAS()
        raise

    if DEBUG: print("Checking if can delete GWD.")
    if DEBUG: print("MOVERESULTS = {} and GWD_CLEAN = {}".format(MOVERESULTS, GWD_CLEAN))
    if MOVERESULTS and GWD_CLEAN:
        ## remove GWD folder
        try:
            if DEBUG: print("Trying to remove.")
            os.rmdir(os.path.join("/genesis", GWD[1:]))
        except OSError as exception:
            logMessage("ERROR: {}".format(exception))
            sys.exit("Error removing Genesis directory.")
    logMessage("All jobs have completed. Closing.")
